# JS Fetch

## Lernziele

- Verstehen, wie asynchroner Code funktioniert
- Verstehen, wie man mit Promises und `async/await` arbeitet
- Die Fetch API verstehen
  - mit async/await
  - JSON
  - HTTP-Statuscodes
  - REST-API
  - Fehlerbehandlung

---

## Asynchroner Code

Asynchroner Code ist Code, der im Hintergrund lÃ¤uft. Dies ist nÃ¼tzlich fÃ¼r Aufgaben, die lange dauern kÃ¶nnen, aber den Hauptthread nicht blockieren mÃ¼ssen.

JavaScript ist eine Single-Threaded-Sprache, was bedeutet, dass immer nur eine Sache gleichzeitig passieren kann.

Das Blockieren des Hauptthreads ist schlecht, weil es den Benutzer daran hindert, mit der Seite zu interagieren, da kein anderer JavaScript-Code ausgefÃ¼hrt werden kann. Beispiele fÃ¼r asynchronen Code sind: Netzwerk-Anfragen, Dateisystemzugriffe, Animationen und Timer.

## Promises

Asynchrone Funktionen geben ihren RÃ¼ckgabewert nicht direkt zurÃ¼ck, sondern stattdessen ein Promise. Ein Promise ist ein Objekt, das den endgÃ¼ltigen Abschluss (oder Misserfolg) einer asynchronen Operation und deren resultierenden Wert darstellt. Meistens wird es von einer Funktion zurÃ¼ckgegeben, die eine asynchrone Operation durchfÃ¼hrt.
Es gibt zwei Hauptmethoden, um mit asynchronen Funktionen umzugehen: Arbeiten mit Promises oder Arbeiten mit `async/await`.

## Asynchroner Code mit Promises

Du kannst die `then`-Methode mit einer Callback-Funktion verwenden, um auf den Abschluss der asynchronen Operation zu reagieren.

```js
asynchronousFunction().then((value) => {
  console.log(value);
});
```

> ğŸ’¡ Promises werden fast immer von anderen asynchronen APIs fÃ¼r dich erstellt. Nur selten erstellst du sie selbst. Wenn du ein Promise selbst erstellst (new Promise()), weiÃŸt du entweder genau, was du tust, oder du machst wahrscheinlich etwas falsch.

---

## Asynchroner Code mit `async/await`

Async-Funktionen sind eine syntaktische Vereinfachung fÃ¼r Promises. Mit dem `await`-SchlÃ¼sselwort kannst du asynchronen Code schreiben, der wie synchroner Code aussieht. Jede Funktion kann mit dem `async`-SchlÃ¼sselwort versehen werden:

```js
async function myAsyncFunction() {
  // ...
}

const myAsyncArrowFunction = async () => {
  // ...
};
```

Innerhalb einer async-Funktion kannst du das `await`-SchlÃ¼sselwort verwenden, um auf die AuflÃ¶sung eines Promises zu warten:

```js
async function myAsyncFunction() {
  const value = await otherAsynchronousFunction();
  console.log(value);
}
```

> ğŸ’¡ `async`-Funktionen geben immer ein Promise zurÃ¼ck. Wenn die Funktion einen Wert zurÃ¼ckgibt, wird das Promise mit diesem Wert aufgelÃ¶st. Selbst wenn du nicht das `return`-SchlÃ¼sselwort verwendest, wird die Funktion ein Promise zurÃ¼ckgeben, das mit `undefined` aufgelÃ¶st wird, wenn es das Ende ihres GÃ¼ltigkeitsbereichs erreicht.

## Was ist eine API?

Der Begriff _API_ steht fÃ¼r _Application Programming Interface_.

Eine _API_ bietet eine MÃ¶glichkeit, wie eine Software (die Anwendung) mit einer anderen Software interagieren kann. Daher kann eine Anwendung eine Reihe von Funktionen und Regeln definieren, wie andere Software mit ihr interagieren kann. Dies wird als _Schnittstelle_ bezeichnet. Denke an einen Vertrag zwischen zwei Softwares, der erklÃ¤rt, wie sie zusammenarbeiten kÃ¶nnen.

APIs kÃ¶nnen aus verschiedenen Perspektiven betrachtet werden und treten auf verschiedenen Ebenen auf.

Ein Browser bietet viele [Web APIs](https://developer.mozilla.org/en-US/docs/Web/API). Jede Web-API definiert eine MÃ¶glichkeit, wie eine JavaScript-Anwendung eine vom Browser bereitgestellte Funktion nutzen kann, wie zum Beispiel:

- [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API)
- [Battery API](https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API)
- [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)

APIs, die in einer Serverumgebung ausgefÃ¼hrt werden, sind ein anderer Typ von API. Sie werden von einem _Server_ bereitgestellt, im Gegensatz zu den vom Browser bereitgestellten APIs (die auch als _Client_ bezeichnet werden). Ein hÃ¤ufiges Anwendungsfall fÃ¼r solche APIs ist das Lesen / Laden von Daten. Andere Operationen wie das Schreiben oder LÃ¶schen von Daten sind ebenfalls mÃ¶glich. Es gibt gÃ¤ngige AnsÃ¤tze fÃ¼r die Architektur einer serverseitigen API. Ein solcher Ansatz sind REST-APIs, die spÃ¤ter in diesem Dokument erklÃ¤rt werden.

---

## Fetch API (mit async & await)

`fetch` ist eine [web API](https://developer.mozilla.org/en-US/docs/Web/API), um Ressourcen asynchron aus dem Netzwerk zu laden, wie z.B. Textdokumente.

```js
async function fetchData() {
  const response = await fetch("/url/to/something");
  const data = await response.json();
  return data;
}
```

Dies geschieht im obigen Beispiel:

1. Wir markieren die Funktion mit dem `async`-SchlÃ¼sselwort, weil wir `await` innerhalb der Funktion verwenden mÃ¶chten.
2. Wir deklarieren eine Variable namens `response`. Sie speichert das Response-Objekt, das von `fetch` zurÃ¼ckgegeben wird.
3. Sobald dieses Promise aufgelÃ¶st ist (die Netzwerk-Anfrage ist abgeschlossen), rufen wir die `.json`-Methode auf der `response`-Variablen auf. Diese Funktion gibt ein weiteres Promise zurÃ¼ck.
4. Dieses zweite Promise wird mit den tatsÃ¤chlichen Daten (Payload) aufgelÃ¶st, die von JSON (ein formatiertes Zeichenkette) in einen JavaScript-Wert oder -Objekt konvertiert wurden. Dieses Ergebnis wird in der Variable `data` gespeichert.
5. Die Funktion gibt den Wert zurÃ¼ck, der in der Variable `data` gespeichert ist.

> ğŸ’¡ Die async und await-Syntax hilft dabei, mit den beiden aufeinander folgenden Promises umzugehen, die erforderlich sind, um die Antwortdaten zu erhalten (im Gegensatz zur verschachtelten Syntax mit .then()).

> ğŸ’¡Das Response-Objekt bietet weitere nÃ¼tzliche Methoden (alle geben Promises zurÃ¼ck), darunter die folgenden:

> response.json() gibt ein Promise zurÃ¼ck, das in die heruntergeladenen Daten JSON-geparst als JavaScript-Wert oder -Objekt aufgelÃ¶st wird
> response.text() gibt ein Promise zurÃ¼ck, das in die heruntergeladenen Daten als Rohtext aufgelÃ¶st wird
> response.formData() gibt ein Promise zurÃ¼ck, das in die heruntergeladenen Daten als FormData aufgelÃ¶st wird
> response.blob() gibt ein Promise zurÃ¼ck, das in die heruntergeladenen Daten als Roh-Blob (das ist ein maschinenlesbares Format mit Nullen und Einsen) aufgelÃ¶st wird

---

## JSON

JavaScript Object Notation (JSON) ist ein standardisiertes textbasiertes Format zur Darstellung von strukturierten Daten basierend auf der JavaScript-Objektsyntax. Es wird hÃ¤ufig verwendet, um Daten zwischen einem Client (Browser) und einem Server in Webanwendungen zu Ã¼bertragen.

JSON ist sehr nah dran, ein Subset der JavaScript-Syntax zu sein. Die meisten gÃ¼ltigen JSON-Daten sind auch gÃ¼ltiger JavaScript-Code. Das bedeutet, dass du JSON in jede `.js`-Datei kopieren kannst, ein `const myData =` davor setzen kannst und zuschauen kannst, wie Prettier es wie echtes JavaScript aussehen lÃ¤sst. Auf der anderen Seite ist gÃ¼ltiges JavaScript kein gÃ¼ltiges JSON. Es sieht so aus:

```json
{
  "groupName": "Students",
  "groupSize": 100,
  "students": [
    {
      "name": "John Doe",
      "age": 42,
      "location": "Pleasantville",
      "member": true,
      "groups": ["students", "citizens", "new"]
    },
    {
      "name": "Jane Doe",
      "age": 44,
      "location": "Pleasantville",
      "member": true,
      "groups": ["students", "citizens", "new"]
    },
    {
      "name": "Sam Doe",
      "age": 24,
      "location": "Pleasantville",
      "member": true,
      "groups": ["students", "citizens", "new"]
    }
  ]
}
```

Obwohl es stark der JavaScript-Objektsyntax Ã¤hnelt, kann es auÃŸerhalb von JavaScript verwendet werden. Andere Programmiersprachen bieten oft die MÃ¶glichkeit, JSON zu lesen (zu parsen).

JSON existiert als Zeichenkette, die in ein natives JavaScript-Objekt konvertiert werden muss, wenn du auf die Daten zugreifen mÃ¶chtest. Kein Problem! - JavaScript bietet ein globales JSON-Objekt, das Konvertierungsmethoden in beide Richtungen enthÃ¤lt.

> ğŸ’¡ JSON-Konvertierungsmethoden

> JSON.parse()

> Diese Methode parst eine JSON-Zeichenkette und konstruiert den durch die Zeichenkette beschriebenen JavaScript-Wert oder -Objekt.

> JSON.stringify()

> Diese Methode konvertiert einen JavaScript-Wert oder -Objekt in eine JSON-Zeichenkette.

---

## HTTP Response Status Codes

HTTP-Antwortstatuscodes geben normalerweise an, ob eine bestimmte HTTP-Anfrage erfolgreich abgeschlossen wurde. Meistens wird _jede Art_ von Antwort als erfolgreicher Abschluss der Anfrage angesehen.

Mit Ausnahme von benutzerdefinierter Serversoftware sind diese Antworten standardisiert. Eine Liste der HTTP-Antwortstatuscodes findest du [hier](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

Einer der bekanntesten HTTP-Antwortstatuscodes ist [`404 not found`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404), den die meisten Webbenutzer wahrscheinlich schon einmal gesehen haben.

> ğŸ’¡ Brauchst du eine niedliche ErklÃ¤rung, was die HTTP-Antwortcodes bedeuten? Suche einfach nach 'HTTP status dogs' (oder Katzen, wenn du sie lieber magst).

---

## Fehlerbehandlung

Es mag Ã¼berraschen, dass `fetch()` keinen Fehler auslÃ¶st, wenn der Server einen schlechten HTTP-Status zurÃ¼ckgibt, z.B. Client- oder Serverfehler.

```js
async function fetchSomething() {
  const response = await fetch("/bad/url/oops");
  const something = await response.json();
  return something;
}
```

Angenommen, dass im obigen Beispiel `'bad/url/oops` nicht zu einem vorhandenen Ort fÃ¼hrt, wÃ¼rde der Server mit dem Statuscode `404` und dem Text `Page not found` antworten. Dies ist eine **abgeschlossene** HTTP-Anfrage.

Eine Anfrage wird nur als abgelehnt registriert, wenn keine Antwort abgerufen werden kann. Dies kann aufgrund von Netzwerkproblemen geschehen, wie z.B. keine Internetverbindung, der Host wurde nicht gefunden oder der Server antwortet nicht.

Wir kÃ¶nnen _gute_ von _schlechten_ HTTP-Antwortstatuscodes unterscheiden, indem wir uns auf die boolesche `response.ok`-Eigenschaft verlassen. Sie ist nur dann auf `true` gesetzt, wenn der HTTP-Antwortcode zwischen `200-299` liegt.

In unserem obigen Beispiel wÃ¤re `response.ok` auf `false` gesetzt und der Antwortcode wÃ¤re `404`.

Wenn etwas schiefgeht und wir keine Antwort erhalten, lÃ¶st die Fetch API einen Fehler aus. Sobald ein Fehler ausgelÃ¶st wird, stoppt die AusfÃ¼hrung und JavaScript sucht nach dem nÃ¤chsten `catch`-Block.

Jeder produktionsreife `fetch`-Aufruf sollte sich in einem `try...catch`-Block befinden:

```js
async function fetchSomething() {
  try {
    const response = await fetch("/bad/url/oops");

    if (response.ok) {
      // Erfolg (Gute Antwort)
      const data = await response.json();
      return data;
    } else {
      // Fehler (Schlechte Antwort)
      console.error("Bad Response");
    }
  } catch (error) {
    // Fehler (Netzwerkfehler usw.)
    console.error("Ein Fehler ist aufgetreten");
  }
}
```

## REST API

Wenn du eine API erstellst, musst du dir Gedanken darÃ¼ber machen, wie du deine API strukturierst, die Funktionen, die du bereitstellst, und welche Regeln du anwendest. Dies wird als die Architektur deiner API bezeichnet.

Es gibt verschiedene gÃ¤ngige AnsÃ¤tze, die im Web verwendet werden. Ein sehr beliebter ist die REST-API oder RESTful-API.

REST ist eine Sammlung von architektonischen EinschrÃ¤nkungen, kein Protokoll oder Standard. Du als API-Entwickler kannst REST auf verschiedene Weisen implementieren.

> ğŸ’¡ REST steht fÃ¼r REpresentational State Transfer

Die Grundidee sieht so aus:

- Ein _Client_ fordert eine _Ressource_ von einem _Server_ an (wie ein Dokument, das Informationen zu einem bestimmten Thema enthÃ¤lt)
- Der _Server_ formuliert eine Antwort, die die Ressource in einem Format darstellt, das der _Client_ versteht (wie JSON - andere Formate wie HTML, XML oder Klartext sind ebenfalls mÃ¶glich)
- Dieser Datentransfer Ã¤ndert den Zustand der Webanwendung.

Jede Ressource hat eine eindeutige Adresse. Die gesamte Kommunikation erfolgt Ã¼ber HTTP und verwendet verschiedene HTTP-Methoden (wie GET/POST/PUT/DELETE), um gewÃ¼nschte Aktionen zu beschreiben.

> ğŸ’¡ Dies ist eine sehr grundlegende und unvollstÃ¤ndige ErklÃ¤rung. Wenn du mehr darÃ¼ber erfahren mÃ¶chtest, was eine API RESTful macht, kannst du es [hier](https://restfulapi.net/) nachlesen.

---

## Ressourcen

- [Thread on mdn](https://developer.mozilla.org/en-US/docs/Glossary/Thread)
- [Asynchronous on mdn](https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous)
- [Using Promises on mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
- [Async functions on mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
- [Promise.all() on mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
- [try...catch on mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)
