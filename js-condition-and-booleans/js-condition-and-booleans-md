# JS Bedingungen und Booleans

## Lernziele

- Verwendung von Bedingungen zur Steuerung des Programmflusses
- Verstehen, was Booleans und truthy/falsy Werte sind
- Arbeiten mit Vergleichs- und logischen Operatoren
- Schreiben von tern√§ren Ausdr√ºcken

---

## Boolean-Werte

Ein Boolean-Wert, benannt nach George Boole, hat nur zwei Zust√§nde. Er kann entweder **true** oder **false** sein. Booleans werden oft in bedingten Anweisungen verwendet, die je nach ihrem Wert unterschiedlichen Code ausf√ºhren k√∂nnen.

## Truthy- und Falsy-Werte

Manchmal m√∂chte man eine Bedingung basierend auf einem anderen Typ von Wert haben. JavaScript kann jeden Wert durch _Typumwandlung_ in einen Boolean verwandeln. Das bedeutet, dass einige Werte sich so verhalten, als w√§ren sie true, und andere, als w√§ren sie false: _Truthy_-Werte werden zu true, _falsy_-Werte werden zu false.

- _truthy_ Werte:

  - Zahlen ungleich Null: `1`, `2`, `-3` usw.
  - Nicht leere Strings: `"hello"`
  - `true`

- _falsy_ Werte:
  - `0` / `-0`
  - `null`
  - `false`
  - `undefined`
  - Leerer String: `""`

---

## Vergleichsoperatoren

Vergleichsoperatoren erzeugen Boolean-Werte, indem sie zwei Ausdr√ºcke vergleichen:

| Operator  | Wirkung                                                                                      |
| --------- | -------------------------------------------------------------------------------------------- |
| A `===` B | strikt gleich: ist `true`, wenn beide Werte gleich sind (einschlie√ülich ihres Typs).         |
| A `!==` B | strikt ungleich: ist `true`, wenn beide Werte nicht gleich sind (einschlie√ülich ihres Typs). |
| A `>` B   | strikt gr√∂√üer als: ist `true`, wenn A gr√∂√üer als B ist.                                      |
| A `<` B   | strikt kleiner als: ist `true`, wenn A kleiner als B ist.                                    |
| A `>=` B  | gr√∂√üer als oder gleich: ist `true`, wenn A gr√∂√üer als oder gleich B ist.                     |
| A `<=` B  | kleiner als oder gleich: ist `true`, wenn A kleiner als oder gleich B ist.                   |

> üí° Du wirst vielleicht bemerken, dass JavaScript drei Gleichheitszeichen (`===`) verwendet, um auf Gleichheit zu pr√ºfen. Das kann anfangs sehr ungew√∂hnlich erscheinen.
>
> - `=` (`const x = 0`) ist der Zuweisungsoperator und hat nichts mit Vergleich zu tun.
> - `==` und `!=` sind nicht-strikte Gleichheitsoperatoren. Du solltest **sie 99% der Zeit vermeiden**.  
>   Nicht-strikte Gleichheit versucht, beide Werte mithilfe von Typumwandlung in denselben Typ zu konvertieren: `"3" == 3` ergibt `true`, was selten das ist, was du willst.
> - `===` und `!==` sind strikte Gleichheitsoperatoren. **Das ist fast immer das, was du brauchst**.  
>   Strikte Gleichheit pr√ºft, ob Typ _und_ Wert gleich sind: `"3" === 3` ergibt `false`.

---

## Logische Operatoren

Logische Operatoren kombinieren bis zu zwei Booleans zu einem neuen Boolean.

| Operator                      | Wirkung                                                     |
| ----------------------------- | ----------------------------------------------------------- |
| `!`A                          | `not`: kehrt einen `true` Wert in `false` um und umgekehrt. |
| A <code>&#124;&#124;</code> B | `or`: ist `true`, wenn entweder A `oder` B `true` ist.      |
| A `&&` B                      | `and`: ist `true`, wenn sowohl A `und` B `true` sind.       |

> üí° Du kannst logische Operatoren mit Klammern kombinieren, um festzulegen, welcher Operator zuerst ausgewertet werden soll, z.B.:
>
> - `(A || B) && (C || D)`
> - `!(A || B)`

> üí° Sei vorsichtig beim Verwenden von `&&` oder `||` mit nicht-boolean Werten. Sie geben tats√§chlich einen der urspr√ºnglichen Werte zur√ºck. Das kann n√ºtzlich sein, kann aber auch schnell zu Verwirrung f√ºhren. Dieses Verhalten wird als
> [Kurzschlussbewertung](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#short-circuit_evaluation)
> bezeichnet und ist ein fortgeschrittenes Thema.
>
> - `"some string" || "some other string"` ergibt `"some string"`
> - `0 || 100` ergibt `100`
> - `null && "yet another string"` ergibt `null`

---

## Steuerfluss: `if / else`

Mit einer if-Anweisung k√∂nnen wir steuern, ob ein Teil unseres Codes ausgef√ºhrt wird oder nicht, basierend auf einer Bedingung.

```js
const isSunShining = true;

if (isSunShining) {
  // Code, der nur ausgef√ºhrt wird, wenn die Bedingung "isSunShining" true ist
}
Der else-Block wird nur ausgef√ºhrt, wenn die Bedingung false ist.

js
Code kopieren
const isSunShining = false;

if (isSunShining) {
  // Code, der nur ausgef√ºhrt wird, wenn die Bedingung "isSunShining" true ist
} else {
  // Code, der nur ausgef√ºhrt wird, wenn die Bedingung "isSunShining" false ist
}
```

Der Bedingungsausdruck zwischen den `()` Klammern kann ebenfalls aus logischen oder Vergleichsoperatoren bestehen. Du kannst zwischen mehreren F√§llen unterscheiden, indem du `else if`-Anweisungen verkettest:

```js
if (hour < 12) {
  console.log("Guten Morgen.");
} else if (hour < 18) {
  console.log("Guten Nachmittag.");
} else if (hour === 24) {
  console.log("Gute Nacht.");
} else {
  console.log("Guten Abend.");
}
```

Wenn die Bedingung kein Boolean ist, wird sie durch Typumwandlung in einen Boolean konvertiert. Dies kann verwendet werden, um zu √ºberpr√ºfen, ob ein Wert nicht 0 oder ein leerer String ist:

```js
const name = "Alex";
if (name) {
  console.log("Hi " + name + "!"); // wird nur ausgef√ºhrt, wenn name nicht ein leerer String ist
}
```

### Switch

Manchmal m√∂chten wir eine Variable oder einen Ausdruck √ºberpr√ºfen, um zu sehen, ob ihr Wert einer von wenigen sehr spezifischen m√∂glichen Werten ist. In diesem Fall k√∂nnen wir die **switch**-Anweisung verwenden.

Die **switch**-Anweisung funktioniert, indem sie die Variable oder den Ausdruck nimmt und dann nacheinander durch eine Liste von m√∂glichen **F√§llen** f√ºr ihren Wert geht. In jedem `case`, den sie erreicht, vergleicht sie den √ºberpr√ºften Wert mit dem Wert des `case`. Wenn sie √ºbereinstimmen, wird der Code in diesem `case` ausgef√ºhrt. Wenn sie nicht √ºbereinstimmen, wird JavaScript zum n√§chsten `case` in der Reihenfolge weitergehen.

Hier ein Beispiel:

```js
console.log("Was ist deine Lieblingsjahreszeit?");
const userAnswer = "Fr√ºhling";

switch (userAnswer) {
  case "Sommer":
    console.log("Hitze, Sonne und Wellen f√ºr dich üòé");
    break;
  case "Herbst":
    console.log("Knisprige, bunte Bl√§tter und k√ºhle Brisen üçÅ");
    break;
  case "Winter":
    console.log("Eis, Schnee, warme Kleidung und hei√üe Getr√§nke ‚òïÔ∏è");
    break;
  case "Fr√ºhling":
    console.log("Wachstum, Gr√ºn und neue Anf√§nge! üåø");
    break;
  default:
    console.log(
      "Entschuldigung, ich glaube nicht, dass das eine Jahreszeit ist!"
    );
}
```

Wichtige Hinweise zur `switch`-Anweisung:

1. Wie bei einer if-Anweisung musst du den √ºberpr√ºften Wert/Ausdruck in Klammern setzen
2. Wie bei einer if-Anweisung, den gesamten Block der switch-Anweisung in geschweifte Klammern setzen
3. Jeder case bietet einen einzelnen Wert (nicht einen Ausdruck!) zur √úberpr√ºfung an
4. Nach dem Wert des case muss ein Doppelpunkt (:) stehen
5. Um zu verhindern, dass JavaScript von einem case zum n√§chsten flie√üt, stelle sicher, dass jeder case mit einem break endet!
6. Du kannst einen default-Fall hinzuf√ºgen, wenn du m√∂chtest; das ist generell eine gute Idee. Er muss nicht mit break enden

## Tern√§rer Operator: `? :``

Mit if / else-Anweisungen kann man ganze Codebl√∂cke steuern. Der tern√§re Operator kann verwendet werden, wenn du zwischen zwei Ausdr√ºcken entscheiden m√∂chtest, z.B. welcher Wert in einer Variable gespeichert werden soll:

```js
const greetingText = time < 12 ? "Guten Morgen." : "Guten Nachmittag.";
```

Der tern√§re Operator hat die folgende Struktur:

```js
condition ? expressionIfTrue : expressionIfFalse;
```

Wenn die Bedingung true ist, wird der erste Ausdruck ausgewertet, andernfalls der zweite Ausdruck. Der tern√§re Operator kann verwendet werden, um zu entscheiden, welche Funktion aufgerufen werden soll:

```js
isUserLoggedIn ? logoutUser() : loginUser();
```

Er kann auch entscheiden, welcher Wert als Argument an eine Funktion √ºbergeben werden soll:

```js
moveElement(xPos > 300 ? 300 : xPos); // das Element kann nicht weiter als 300 bewegt werden.
```

> ‚ùóÔ∏è Der Operator kann nur zwischen zwei _Ausdr√ºcken_ wie Werten, mathematischen/logischen Operationen oder Funktionsaufrufen unterscheiden, nicht zwischen _Anweisungen_ wie Variablendeklarationen, if / else-Anweisungen oder mehrzeiligen Codebl√∂cken.

---

## Fortgeschritten: Die Eigenart der Boolean-Koerzierung und die Nutzung nicht-strikter Gleichheit

<details>
<summary>ü´£ Dies ist ein fortgeschrittenes Thema und nicht wichtig f√ºr die Herausforderungen. Klicke hier, wenn du neugierig bist.</summary>

Angenommen, du m√∂chtest √ºberpr√ºfen, ob eine Variable einen n√ºtzlichen Wert f√ºr uns hat. `if(variable)` pr√ºft tats√§chlich nicht, ob `variable` definiert ist, sondern ob es truthy ist. Sieh dir diese Beispiele an:

- if(undefined) ‚Üí falsy, wird nicht ausgef√ºhrt
- if(null) ‚Üí falsy, wird nicht ausgef√ºhrt
- if("") ‚Üí falsy, wird nicht ausgef√ºhrt, k√∂nnte aber trotzdem eine n√ºtzliche Variable sein (z.B. wenn der Benutzer ein Eingabefeld leert)
- if(0) ‚Üí falsy, wird nicht ausgef√ºhrt, k√∂nnte aber trotzdem eine n√ºtzliche Variable sein (z.B. wenn der Benutzer den Lautst√§rkepegel auf 0 setzen m√∂chte)
- if(" ") ‚Üí truthy, wird ausgef√ºhrt
- if(-1) ‚Üí truthy, wird ausgef√ºhrt

Es ist n√ºtzlich, eine Variable als nicht vorhanden zu definieren, wenn sie `undefined` oder `null` ist. Wir k√∂nnen dies so √ºberpr√ºfen:

```js
if (variable != null) {
  console.log('Das wird protokolliert, selbst wenn die Variable 0 oder "" ist');
}
```

Dies ist einer der seltenen g√ºltigen Anwendungsf√§lle f√ºr nicht-strikte Vergleiche (`!=` statt `!==`).

JavaScript versucht, die verglichenen Werte in denselben Typ zu zwingen. Und genauso wie `"3" == 3` `true` ist, ist auch `undefined == null` `true`. Das funktioniert auch mit `!=` statt `==`.

> ‚ö†Ô∏è Denke daran, dass dies eine Ausnahme f√ºr die Verwendung nicht-strikter Gleichheit ist. **Strikte Gleichheit sollte ansonsten immer bevorzugt werden.**

</details>

---

## Ressourcen

### Operatoren

[MDN Comparison Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#comparison_operators)

[MDN Logical Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#logical_operators)

### if / else-Anweisungen

[MDN about if else](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)

### Tern√§rer Operator

[MDN Ternary Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)
